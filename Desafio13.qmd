---
title: "Desafio13"
format: html
---

Laboratório 3: SQLite com Polars

Objetivo
Dados relacionais são uma constante no exercício da profissão do estatístico. Esta estratégia permite uma representação mais efetiva de dados estruturados, oferecendo a possibilidade de análises computacionalmente mais eficientes. Neste laboratório, trabalharemos com dados relacionais a partir de uma base de dados SQLite.

Os Dados
O banco de dados para esta atividade é o “IMDb Movie Data”, que possui informações sobre filmes, atores, diretores, gêneros e outros. Para os arquivos indicados abaixo, considere que o símbolo \N representa valores faltantes. Observe com cuidado a extensão dos arquivos para uma indicação do formato do mesmo.

1. title.basics0.tsv.gz (Informações Básicas dos Filmes)

Coluna	Descrição
tconst	Identificador único do título (ex: tt1234567)
titleType	Tipo do título (ex: movie, short, tvSeries)
primaryTitle	Título principal
originalTitle	Título original
isAdult	Indica se é conteúdo adulto (0: não, 1: sim)
startYear	Ano de lançamento/início
endYear	Ano de término (para séries)
runtimeMinutes	Duração em minutos
genres	Gêneros separados por vírgula (ex: Action, Comedy)

2. title.ratings.tsv.gz (Avaliações dos Filmes)

Coluna	Descrição
tconst	Identificador único do título (ex: tt1234567)
averageRating	Nota média dos usuários (escala de 1 a 10)
numVotes	Número de votos recebidos

3. title.principals0.tsv.gz (Elenco e Equipe Técnica)

Coluna	Descrição
tconst	Identificador único do título (ex: tt1234567)
nconst	Identificador único da pessoa (ex: nm1234567)
category	Categoria de trabalho da pessoa (ex: actor, director)
job	Função específica desempenhada (para não-atores)
characters	Personagens interpretados (para atores)

4. movies.sqlite3 (Banco de Dados em SQLite)

Atividade

0. Não esquecer de colocar um comando no código que "printe" o dia e hora que foi compilado o arquivo.

```{r}
# Data e hora de compilação
print(paste("Arquivo compilado em:", Sys.time()))
```

1. Crie um banco de dados SQLite utilizando os 3 arquivos acima. O banco de dados deve conter as seguintes tabelas: basics, ratings e principals

```{r}
library(DBI)
library(RSQLite)
library(dplyr)
library(readr)

# Criar conexão com o banco de dados
con <- dbConnect(SQLite(), "movies.sqlite")

# Função para ler arquivos TSV compactados
read_tsv_gz <- function(file_path) {
  read_tsv(gzfile(file_path), na = "\\N", quote = "")
}

# Carregar e criar tabelas no SQLite
tryCatch({
  # Ler dados
  basics_df <- read_tsv_gz("title.basics0.tsv.gz")
  ratings_df <- read_tsv_gz("title.ratings.tsv.gz")
  principals_df <- read_tsv_gz("title.principals0.tsv.gz")
  
  # Escrever para SQLite
  dbWriteTable(con, "basics", basics_df, overwrite = TRUE)
  dbWriteTable(con, "ratings", ratings_df, overwrite = TRUE)
  dbWriteTable(con, "principals", principals_df, overwrite = TRUE)
  
  cat("Banco de dados criado com sucesso!\n")
}, error = function(e) {
  cat("Erro ao criar banco de dados:", e$message, "\n")
})
```


2. (Utilizando SQL, responda): Quais são os 5 filmes com as maiores notas (averageRating)? Apresente uma solução capaz de desempatar os filmes baseando-se no número de votos recebidos.

```{r}
# Consulta SQL para os 5 melhores filmes
query2 <- "
SELECT b.primaryTitle, r.averageRating, r.numVotes, b.startYear
FROM basics b
JOIN ratings r ON b.tconst = r.tconst
WHERE b.titleType = 'movie' 
  AND b.isAdult = 0
  AND b.startYear IS NOT NULL
ORDER BY r.averageRating DESC, r.numVotes DESC
LIMIT 5
"

result2 <- dbGetQuery(con, query2)
print("Top 5 filmes com maiores notas:")
print(result2)
```

3. (Utilizando SQL, responda): Qual é o gênero mais frequente entre os filmes com nota maior que 8?

```{r}
query3 <- "
WITH filmes_nota_alta AS (
  SELECT b.tconst, b.genres
  FROM basics b
  JOIN ratings r ON b.tconst = r.tconst
  WHERE b.titleType = 'movie'
    AND r.averageRating > 8
    AND b.genres IS NOT NULL
    AND b.genres != '\\N'
),
generos_separados AS (
  SELECT 
    trim(g.value) as genero
  FROM filmes_nota_alta f,
  json_each('[\"' || replace(f.genres, ',', '\",\"') || '\"]') g
)
SELECT 
  genero,
  COUNT(*) as frequencia
FROM generos_separados
GROUP BY genero
ORDER BY frequencia DESC
LIMIT 1
"

result3 <- dbGetQuery(con, query3)
print("Gênero mais frequente em filmes com nota > 8:")
print(result3)
```

4.(Utilizando SQL, responda): Quais são os 3 atores/atrizes que mais participaram de filmes com nota maior que 7.5?

```{r}
query4 <- "
SELECT 
  p.nconst,
  COUNT(*) as total_filmes
FROM principals p
JOIN ratings r ON p.tconst = r.tconst
WHERE r.averageRating > 7.5
  AND p.category IN ('actor', 'actress')
GROUP BY p.nconst
ORDER BY total_filmes DESC
LIMIT 3
"

result4 <- dbGetQuery(con, query4)
print("Top 3 atores/atrizes em filmes com nota > 7.5:")
print(result4)
```

```{r}
# Fechar conexão
dbDisconnect(con)
```
